<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[《数据结构与算法分析》一二章学习笔记]]></title>
    <url>%2F2018%2F12%2F03%2F%E3%80%8A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E3%80%8B%E4%B8%80%E4%B8%80%E4%B8%80%E4%BA%8C%E7%AB%A0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[第一章 引论１. 数学知识、公式整理（1）级数 （2）模运算 如果正整数A与B对N取模，余数相同，记为A≡B(mod N)。若A≡B(mod N)，A+C≡B+C(mod N)，并且AD≡BD(mod N)。 （3）证明方法 （4）递归四条基本法则 a. 基准情形。定义好不需要递归就可以求出的基准； b. 不断推进。后续每一次调用需使求解情况朝接近基准情形的方向推进，像查英译汉的字典一样，查一个我们不会的词的时候又在解释中碰到不认识的词，就要继续查下去，但最后，肯定有一个我们不需要查就认识的单词，此时倒退过来就能明白最初查的词的意思 。 c. 设计法则。假设所有的递归调用均能运行；d. 合成效益法则。因为系统每次递归是要通过开一个固定大小的不相同的内存空间的，所以尽力保证在求解同一问题的同一实例时，切勿在不同的递归调用钟做重复性的工作。 第二章 算法分析1. 时间复杂度 时间复杂度主要用来统计算法执行语句的次数，通过计算时间复杂度，可以判断一个算法执行的相对时间长短。一般情况下，算法中基本操作重复执行的次数是问题规模n的某个函数，用T(N)表示，若有某个助函数f(N),存在一个正常数c使得f(N)*c&gt;=T(N)恒成立。记作T(N)=O(f(N)),称O(f(N)) 为算法的渐进时间复杂度，简称时间复杂度。 注： a. 有两个时间复杂度函数，Tworst(N)和Tavg(N),分别是输入为N时，算法的最坏时间复杂度（主要使用）与平均时间复杂度。 b. 时间复杂度是表示一个函数的趋势,并不代表具体值,当n趋于无穷大时,可以忽略低阶项和首项系数。 2. 计算a. 基本约定 不存在特定的时间单位，假设计算机做任何一件简单工作即花费一个时间单元(声明不计时间)。b.一般规则法则1：for循环 对于一个循环，假设循环体的时间复杂度为 O(n)，循环次数为 m，则这个循环的时间复杂度为 O(n×m)。法则2：嵌套for循环 对于多个循环，假设循环体的时间复杂度为 O(n)，各个循环的循环次数分别是a, b, c……，则这个循环的时间复杂度为 O(n×a×b×c……)。分析的时候应该由里向外分析这些循环。法则3：顺序语句 对于顺序执行的语句或者算法，总的时间复杂度等于其中最大的时间复杂度。法则4：IF/ELSE语句 对于条件判断语句，总的时间复杂度等于其中 时间复杂度最大的路径的时间复杂度。总结 时间复杂度分析的基本策略是：从内（或最深层次）向外分析。如果有函数调用，那么这些调用要首先分析。递归也需要仔细分析。c.运行时间中的对数 如果一个算法用常数时间（O(1)）将问题的大小削减为其一部分（通常为1/2），那么该算法就是O(logN)。另一方面，如果使用常数时间只是把时间减少了一个常数，则为O(N)。注： 二分法（logN）,分治法（NlogN）。 3. 最大子序列和联机算法123456789101112131415161718/*该算法适用于序列中至少有一个数非负的场合，时间复杂度为线性的O(N)*/int MaxSubSequenceSum(int A[], int N)&#123; int MaxSum = 0, ThisSum = 0; //ThisSum为当前子序列和 for (int i = 0; i &lt; N; i++) &#123; ThisSum += A[i]; //逐个读取，逐个加 if (ThisSum &gt; MaxSum) &#123; MaxSum = ThisSum; //当前子序列和如果比最大子序列和大，更新 &#125; else if (ThisSum &lt; 0) &#123; ThisSum = 0; //当前子序列和小于0，即舍弃该子序列，重新开始新的子序列 &#125; &#125; return MaxSum;&#125; 只对数据进行一次扫描，一旦a[i]被读入并处理，它就不再需要被记忆。因此数组可以被按顺序读入，在主存中不必存储数组的任何部分。具有这种特性的算法叫联机算法(on-line algorithm)，仅需要常量空间并以线性时间运行的联机算法几乎是完美算法！]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言内存管理与变量生命周期、 作用域梳理]]></title>
    <url>%2F2018%2F11%2F10%2FC%E8%AF%AD%E8%A8%80%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E4%B8%8E%E5%8F%98%E9%87%8F%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E6%A2%B3%E7%90%86%2F</url>
    <content type="text"><![CDATA[C语言的内存管理&#160; &#160; &#160; &#160;C源代码经过预处理、编译、汇编与链接成为一个可执行程序。&#160; &#160; &#160; &#160;C程序在运行之前，未加载到内存前，可执行程序内部已分为3部分信息，BSS区（未初始化数据区）、Data（全局初始化数据区）、Text(代码区)。&#160; &#160; &#160; &#160;运行可执行程序，程序被加载到内存中，除了根据已有信息分配这三个区外，还额外增加了两个区，栈区（stack）和堆（heap）区。具体关系如图所示。 &#160; &#160; &#160; &#160;&#160; &#160; &#160; &#160; &#160; 注： 所有未初始化的全局变量与静态变量，编译器会默认赋初值为0； 程序在加载到内存前，代码区和全局区（data与bss）的大小固定，且程序运行期间不能改变； data区与bss区中数据的生命周期为整个程序运行期间； data区、bss区与text区是由编译器在编译时分配的，堆和栈实在程序运行时分配的。 变量生命周期与作用域&#160;&#160;&#160;&#160;&#160;&#160;&#160;作用域分为全局作用域、局部作用域与文件作用域。 1） 普通全局变量&#160;&#160;&#160;&#160;&#160;&#160;&#160;作用域：全局作用域（只在一个源文件定义，多个源文件均可以使用，外部引用需用extern关键字声明）。&#160;&#160;&#160;&#160;&#160;&#160;&#160;生命周期：从编译到程序运行期间一直存在。&#160;&#160;&#160;&#160;&#160;&#160;&#160;内存分布：data区（初始化）与bss区（未初始化）。 2） 静态全局变量&#160;&#160;&#160;&#160;&#160;&#160;&#160;作用域：文件作用域（只能在定义的文件中使用，不允许外部调用）&#160;&#160;&#160;&#160;&#160;&#160;&#160;生命周期：从编译到程序运行期间一直存在。&#160;&#160;&#160;&#160;&#160;&#160;&#160;内存分布：data区（初始化）与bss区（未初始化）。 3） 普通局部变量&#160;&#160;&#160;&#160;&#160;&#160;&#160;作用域：局部作用域。&#160;&#160;&#160;&#160;&#160;&#160;&#160;生命周期：从定义到程序出局部作用域即被销毁（即属于某个{}，程序执行到{即分配内存，执行到}即销毁，下次进入再重新分配。）&#160;&#160;&#160;&#160;&#160;&#160;&#160;内存分布：栈区。 4） 静态局部变量&#160;&#160;&#160;&#160;&#160;&#160;&#160;作用域：局部作用域。&#160;&#160;&#160;&#160;&#160;&#160;&#160;生命周期：从编译到程序运行期间一直存在。&#160;&#160;&#160;&#160;&#160;&#160;&#160;内存分布：data区（初始化）与bss区（未初始化）。 5） 寄存器变量&#160;&#160;&#160;&#160;&#160;&#160;&#160;作用域：局部作用域&#160;&#160;&#160;&#160;&#160;&#160;&#160;生命周期：无&#160;&#160;&#160;&#160;&#160;&#160;&#160;内存分布：使用CPU的寄存器，无地址，不占用内存。 注： &#160;&#160;&#160;&#160;&#160;&#160;&#160;为了提高效率，C 语言允许将局部变量的值放在 CPU 中的寄存器中，这种变量叫“寄存器变量”，用关键字register作声明。&#160;&#160;&#160;&#160;&#160;&#160;&#160;只有局部自动变量和形式参数可以作为寄存器变量；&#160;&#160;&#160;&#160;&#160;&#160;&#160;一个计算机系统中的寄存器数目有限，不能定义任意多个寄存器变量；&#160;&#160;&#160;&#160;&#160;&#160;&#160;局部静态变量不能定义为寄存器变量。 关于static变量使用的一些tips: 若全局变量仅在单个C文件中访问，则可以将这个变量修改为静态全局变量，以降低模块间的耦合度； 若全局变量仅由单个函数访问，则可以将这个变量改为该函数的静态局部变量，以降低模块间的耦合度； 设计和使用访问动态全局变量、静态全局变量、静态局部变量的函数时，需要考虑重入问题，因为他们都放在静态数据存储区，全局可见; 如果我们需要一个可重入的函数，那么，我们一定要避免函数中使用static变量(这样的函数被称为：带“内部存储器”功能的的函数)； 函数中必须要使用static变量情况:比如当某函数的返回值为指针类型时，则必须是static的局部变量的地址作为返回值，若为auto类型，则返回为错指针。 总结&#160;&#160;&#160;&#160;&#160;&#160;&#160;全局变量和静态变量是在程序编译期就分配到data段或bss段中的，在整个程序的运行期，数据段和bss段中的内容是不会发生改变的。所以所有的全局变量和静态变量的生命周期必定是从程序编译到程序运行结束。而且如果全局变量和静态变量没有初始化，会统一默认初始化为0.&#160;&#160;&#160;&#160;&#160;&#160;&#160;而局部变量是在程序的运行时，在栈中分配的内存，所以生命周期一定是从程序运行的某一个时刻开始。]]></content>
      <categories>
        <category>编程基础</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F11%2F08%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
